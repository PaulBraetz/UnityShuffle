@page "/"
@using System.Text
@using System.Collections.Concurrent
@implements IDisposable

<div class="d-flex flex-column">
	<div class="d-flex justify-content-center">
		<div class="rounded shadow d-flex flex-column m-2 p-2">
			<dl class="mb-0">
				<dt>
					Active Rooms
				</dt>
				<dd>
					@rooms.Count()
				</dd>
				<dt>
					Your Room
				</dt>
				<dd>
					@ownRoom.PublicKey
				</dd>
			</dl>
			<span class="border-bottom my-3 border-dark"></span>
			<label for="newCardTitleInput">
				Title (Required)
			</label>
			<div>
				<input id="newCardTitleInput" type="text" @bind-value="@newCardTitle" />
			</div>
			<label for="newCardTaskInput">
				Task
			</label>
			<div>
				<input id="newCardTaskInput" type="text" @bind-value="@newCardTask" />
			</div>
			<div class="mt-1">
				<div class="btn-group">
					@if (!String.IsNullOrWhiteSpace(newCardTitle))
					{
						<button class="btn btn-outline-primary" @onclick="()=>{
							ownRoom.Game.Add(new Room.Card(newCardTitle, newCardTask));
							newCardTitle = string.Empty;
							newCardTask = string.Empty;
						}">
							Add
						</button>
					}
					else
					{
						<button class="btn btn-outline-primary" disabled>
							Add
						</button>
					}
					@if (ownRoom.Game.Cards.Any())
					{
						<button class="btn btn-outline-primary" @onclick="ownRoom.Game.Shuffle">
							Shuffle
						</button>
					}
					else
					{
						<button class="btn btn-outline-primary" disabled>
							Shuffle
						</button>
					}
					@if (ownRoom.Game.Next != Room.Card.Empty)
					{
						<button class="btn btn-outline-primary" @onclick="ownRoom.Game.Skip">
							Skip
						</button>
					}
					else
					{
						<button class="btn btn-outline-primary" disabled>
							Skip
						</button>
					}

					@if (ownRoom.Game.Next != Room.Card.Empty)
					{
						<button class="btn btn-outline-primary" @onclick="ownRoom.Game.Draw">
							Draw
						</button>
					}
					else
					{
						<button class="btn btn-outline-primary" disabled>
							Draw
						</button>
					}
					@if (ownRoom.Game.Top != Room.Card.Empty)
					{
						<button class="btn btn-outline-primary" @onclick="ownRoom.Game.Join">
							Join
						</button>
					}
					else
					{
						<button class="btn btn-outline-primary" disabled>
							Join
						</button>
					}
				</div>
			</div>
			@if (ownRoom.Game.Cards.Any())
			{
				<dl>
					<dt>
						Drawn
					</dt>
					<dd class="text-primary">
						@ownRoom.Game.Top.Title
					</dd>
					<dt>
						Next
					</dt>
					<dd class="text-info">
						@ownRoom.Game.Next.Title
					</dd>
					<dt>
						Cards
					</dt>
					<dd>
						<ul>
							@foreach (var card in ownRoom.Game.Cards.Reverse())
							{
								<li>
									<div class="d-flex flex-column">
										<div>
											@if (card == ownRoom.Game.Top)
											{
												<span class="text-primary">
													@card.Title&nbsp;
												</span>
											}
											else if (card == ownRoom.Game.Next)
											{
												<span class="text-info">
													@card.Title&nbsp;
												</span>
											}
											else
											{
												<span>
													@card.Title&nbsp;
												</span>
											}
											<span class="text-danger" style="cursor:pointer" @onclick="()=>ownRoom.Game.Remove(card)">
												(remove)
											</span>
										</div>
										@if (!String.IsNullOrWhiteSpace(card.Task))
										{
											<div class="pl-5">
												&rarr; @card.Task
											</div>
										}
									</div>
								</li>
							}
						</ul>
					</dd>
				</dl>
			}
		</div>
	</div>
	<div class="d-flex justify-content-center">
		<div class="rounded shadow d-flex flex-column m-2 p-2">
			<label for="joinKeyInput">
				Join Room
			</label>
			<div>
				<input id="joinKeyInput" type="text" @bind-value="@joinKey" />
			</div>
			@if (!String.IsNullOrWhiteSpace(joinKey))
			{
				<div>
					<button class="mt-1 btn btn-outline-primary" @onclick="Join">
						Join
					</button>
				</div>
			}
			else
			{
				<div>
					<button class="mt-1 btn btn-outline-primary" disabled>
						Join
					</button>
				</div>
			}
			@if (joined != null)
			{
				<dl class="mt-1 mb-0">
					<dt>
						Joined
					</dt>
					<dd>
						@joined.PublicKey
					</dd>
					@if (joined.Game.Top != Room.Card.Empty)
					{
						<dt>
							Current Card @if (showNotification)
							{
								<span class="text-success" style="cursor:pointer" @onclick="()=>showNotification=false">NEW</span>
							}
						</dt>
						<dd>
							@joined.Game.Top.Title
						</dd>
						@if (!string.IsNullOrWhiteSpace(joined.Game.Top.Task))
						{
							<dt>
								Current Task
							</dt>
							<dd>
								@joined.Game.Top.Task
							</dd>
						}
					}
				</dl>
			}
		</div>
	</div>
</div>



@code {
	sealed class Room : IDisposable
	{
		public readonly struct Card : IEquatable<Card>
		{
			public Card(String title, String task)
			{
				Title = title;
				Task = task;
			}
			public static readonly Card Empty = new();

			public readonly String Title;
			public readonly String Task;

			public override Boolean Equals(Object? obj)
			{
				return obj is Card card && Equals(card);
			}

			public Boolean Equals(Card other)
			{
				return Title == other.Title && Task == other.Task;
			}

			public override Int32 GetHashCode()
			{
				return HashCode.Combine(Title);
			}

			public static Boolean operator ==(Card left, Card right)
			{
				return left.Equals(right);
			}

			public static Boolean operator !=(Card left, Card right)
			{
				return !(left == right);
			}
		}

		public sealed class CardGame
		{
			private Stack<Card> Deck = new Stack<Card>();
			private Stack<Card> Drawn = new Stack<Card>();
			public Card Top => Drawn.TryPeek(out var top) ? top : Card.Empty;
			public Card Next => Deck.TryPeek(out var next) ? next : Card.Empty;

			public IEnumerable<Card> Cards
			{
				get
				{
					foreach (var card in Drawn)
					{
						yield return card;
					}
					foreach (var card in Deck)
					{
						yield return card;
					}
				}
			}

			public void Add(Card card)
			{
				Deck.Push(card);
			}

			public void Remove(Card card)
			{
				removeFrom(ref Deck);
				removeFrom(ref Drawn);

				void removeFrom(ref Stack<Card> stack)
				{
					var newStack = new Stack<Card>();

					while (stack.TryPop(out var c))
					{
						if (c != card)
						{
							newStack.Push(c);
						}
					}

					stack = newStack;
				}
			}

			public void Shuffle()
			{
				var cards = new List<Card>();

				while (Deck.TryPop(out var c))
				{
					cards.Add(c);
				}

				while (cards.Any())
				{
					var index = Random.Shared.Next(0, cards.Count());
					var card = cards.ElementAt(index);
					Deck.Push(card);
					cards.RemoveAt(index);
				}
			}

			public void Join()
			{
				while (Drawn.TryPop(out var c))
				{
					Deck.Push(c);
				}
			}

			public void Draw()
			{
				if (Deck.TryPop(out var c))
				{
					Drawn.Push(c);
					CardDrawn?.Invoke(this, Drawn.Peek());
				}
			}

			public void Skip()
			{
				if (Next != Card.Empty)
				{
					var next = Deck.Pop(); ;
					var hold = new Stack<Card>();
					while (Deck.TryPop(out var c))
					{
						hold.Push(c);
					}
					hold.Push(next);
					while (hold.TryPop(out var c))
					{
						Deck.Push(c);
					}
				}
			}

			public event EventHandler<Card>? CardDrawn;
		}

		public Room()
		{
			var key = String.Empty;
			var bytes = new Byte[4];
			do
			{
				Random.Shared.NextBytes(bytes);
				key = BitConverter.ToString(bytes).Replace("-", "");
			} while (!rooms.TryAdd(key, this));
			PublicKey = key;
			Game = new CardGame();
			NewRoomCreated?.Invoke(this, EventArgs.Empty);
		}

		public readonly String PublicKey;
		public readonly CardGame Game;
		public event EventHandler? RoomDisposed;


		public void Dispose()
		{
			this.RoomDisposed?.Invoke(this, EventArgs.Empty);
			Index.RoomDisposed?.Invoke(this, EventArgs.Empty);
		}
	}

	private static ConcurrentDictionary<String, Room> rooms = new();

	private Room ownRoom = new();

	private Room? joined;
	private String joinKey = String.Empty;
	private Boolean showNotification;

	private static event EventHandler? NewRoomCreated;
	private static event EventHandler? RoomDisposed;

	private String newCardTitle = String.Empty;
	private String newCardTask = String.Empty;

	protected override void OnInitialized()
	{
		NewRoomCreated += (sender, args) =>
					{
						InvokeAsync(StateHasChanged);
					};
		RoomDisposed += (sender, args) =>
					{
						InvokeAsync(StateHasChanged);
					};
	}

	private void Join()
	{
		if (rooms.TryGetValue(joinKey, out joined))
		{
			joined.Game.CardDrawn += async (sender, card) =>
						{
							showNotification = true;
							await InvokeAsync(StateHasChanged);
							await Task.Delay(10000);
							showNotification = false;
							await InvokeAsync(StateHasChanged);
						};
			joined.RoomDisposed += (sender, args) =>
			{
				joined = null;
				InvokeAsync(StateHasChanged);
			};
			joinKey = String.Empty;
			InvokeAsync(StateHasChanged);
		}
	}

	public void Dispose()
	{
		if (rooms.Remove(ownRoom.PublicKey, out var removed))
		{
			removed.Dispose();
		}
	}
}